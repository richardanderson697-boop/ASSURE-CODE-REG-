# database.py - PostgreSQL Database Models and Configuration

"""
Add to requirements.txt:
sqlalchemy==2.0.25
asyncpg==0.29.0
alembic==1.13.1
psycopg2-binary==2.9.9
"""

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship
from sqlalchemy import String, Integer, DateTime, Boolean, Text, JSON, ForeignKey, Enum
from datetime import datetime
from typing import Optional, List
import enum
import os

# ============================================================================
# DATABASE CONFIGURATION
# ============================================================================

DATABASE_URL = os.getenv(
    "DATABASE_URL",
    "postgresql+asyncpg://scraper:password@localhost:5432/compliance_scraper"
)

# For Railway/Render/Heroku that provide postgres:// URLs
if DATABASE_URL.startswith("postgres://"):
    DATABASE_URL = DATABASE_URL.replace("postgres://", "postgresql+asyncpg://", 1)

engine = create_async_engine(
    DATABASE_URL,
    echo=True,  # Set to False in production
    pool_pre_ping=True,
    pool_size=20,
    max_overflow=10
)

async_session_maker = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False
)

# ============================================================================
# BASE MODEL
# ============================================================================

class Base(DeclarativeBase):
    pass

# ============================================================================
# ENUMS
# ============================================================================

class JobStatus(str, enum.Enum):
    QUEUED = "queued"
    SCRAPING = "scraping"
    PROCESSING = "processing"
    ANALYZING = "analyzing"
    COMPLETED = "completed"
    FAILED = "failed"

class UserRole(str, enum.Enum):
    SUPER_ADMIN = "super_admin"
    ADMIN = "admin"
    USER = "user"
    AUDITOR = "auditor"

class SubscriptionStatus(str, enum.Enum):
    ACTIVE = "active"
    TRIAL = "trial"
    SUSPENDED = "suspended"
    CANCELLED = "cancelled"

# ============================================================================
# MODELS
# ============================================================================

class Organization(Base):
    __tablename__ = "organizations"
    
    id: Mapped[str] = mapped_column(String(36), primary_key=True)
    name: Mapped[str] = mapped_column(String(255), nullable=False)
    subscription_status: Mapped[SubscriptionStatus] = mapped_column(
        Enum(SubscriptionStatus),
        default=SubscriptionStatus.TRIAL
    )
    subscription_tier: Mapped[str] = mapped_column(String(50), default="professional")
    max_jobs_per_month: Mapped[int] = mapped_column(Integer, default=100)
    max_api_calls_per_day: Mapped[int] = mapped_column(Integer, default=1000)
    
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    updated_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow
    )
    
    # Relationships
    users: Mapped[List["User"]] = relationship(back_populates="organization")
    scrape_jobs: Mapped[List["ScrapeJob"]] = relationship(back_populates="organization")
    api_keys: Mapped[List["ApiKey"]] = relationship(back_populates="organization")

class User(Base):
    __tablename__ = "users"
    
    id: Mapped[str] = mapped_column(String(36), primary_key=True)
    organization_id: Mapped[str] = mapped_column(
        String(36),
        ForeignKey("organizations.id", ondelete="CASCADE"),
        nullable=False
    )
    
    # Auth0 integration
    auth0_user_id: Mapped[str] = mapped_column(String(255), unique=True, index=True)
    email: Mapped[str] = mapped_column(String(255), unique=True, nullable=False, index=True)
    
    # Profile
    full_name: Mapped[Optional[str]] = mapped_column(String(255))
    role: Mapped[UserRole] = mapped_column(Enum(UserRole), default=UserRole.USER)
    
    # MFA
    mfa_enabled: Mapped[bool] = mapped_column(Boolean, default=False)
    mfa_secret: Mapped[Optional[str]] = mapped_column(String(255))  # Encrypted
    
    # Status
    is_active: Mapped[bool] = mapped_column(Boolean, default=True)
    last_login: Mapped[Optional[datetime]] = mapped_column(DateTime)
    
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    updated_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow
    )
    
    # Relationships
    organization: Mapped["Organization"] = relationship(back_populates="users")
    scrape_jobs: Mapped[List["ScrapeJob"]] = relationship(back_populates="user")
    audit_logs: Mapped[List["AuditLog"]] = relationship(back_populates="user")

class ScrapeJob(Base):
    __tablename__ = "scrape_jobs"
    
    id: Mapped[str] = mapped_column(String(36), primary_key=True)
    user_id: Mapped[str] = mapped_column(
        String(36),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    organization_id: Mapped[str] = mapped_column(
        String(36),
        ForeignKey("organizations.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    
    # Job configuration
    url: Mapped[str] = mapped_column(Text, nullable=False)
    jurisdiction: Mapped[str] = mapped_column(String(10), nullable=False)
    category: Mapped[str] = mapped_column(String(50), nullable=False)
    max_pages: Mapped[int] = mapped_column(Integer, default=10)
    respect_robots_txt: Mapped[bool] = mapped_column(Boolean, default=True)
    rate_limit_ms: Mapped[int] = mapped_column(Integer, default=2000)
    
    # Job status
    status: Mapped[JobStatus] = mapped_column(Enum(JobStatus), default=JobStatus.QUEUED)
    progress: Mapped[int] = mapped_column(Integer, default=0)
    documents_scraped: Mapped[int] = mapped_column(Integer, default=0)
    error_message: Mapped[Optional[str]] = mapped_column(Text)
    
    # Timestamps
    started_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    completed_at: Mapped[Optional[datetime]] = mapped_column(DateTime)
    
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    updated_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow
    )
    
    # Relationships
    user: Mapped["User"] = relationship(back_populates="scrape_jobs")
    organization: Mapped["Organization"] = relationship(back_populates="scrape_jobs")
    documents: Mapped[List["RegulationDocument"]] = relationship(back_populates="scrape_job")
    analysis: Mapped[Optional["ComplianceAnalysis"]] = relationship(back_populates="scrape_job")

class RegulationDocument(Base):
    __tablename__ = "regulation_documents"
    
    id: Mapped[str] = mapped_column(String(36), primary_key=True)
    scrape_job_id: Mapped[str] = mapped_column(
        String(36),
        ForeignKey("scrape_jobs.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    
    # Document metadata
    title: Mapped[str] = mapped_column(String(500), nullable=False)
    source_url: Mapped[str] = mapped_column(Text, nullable=False)
    publication_date: Mapped[Optional[datetime]] = mapped_column(DateTime)
    effective_date: Mapped[Optional[datetime]] = mapped_column(DateTime)
    agency: Mapped[Optional[str]] = mapped_column(String(255))
    
    # Content
    raw_text: Mapped[str] = mapped_column(Text, nullable=False)
    raw_html: Mapped[Optional[str]] = mapped_column(Text)
    
    # Processing
    text_hash: Mapped[str] = mapped_column(String(64), unique=True, index=True)  # SHA-256
    word_count: Mapped[int] = mapped_column(Integer, default=0)
    
    # Vector embeddings metadata
    embedding_model: Mapped[Optional[str]] = mapped_column(String(100))
    chunk_count: Mapped[int] = mapped_column(Integer, default=0)
    
    scraped_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    
    # Relationships
    scrape_job: Mapped["ScrapeJob"] = relationship(back_populates="documents")
    chunks: Mapped[List["DocumentChunk"]] = relationship(back_populates="document")

class DocumentChunk(Base):
    __tablename__ = "document_chunks"
    
    id: Mapped[str] = mapped_column(String(36), primary_key=True)
    document_id: Mapped[str] = mapped_column(
        String(36),
        ForeignKey("regulation_documents.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    
    # Chunk data
    chunk_index: Mapped[int] = mapped_column(Integer, nullable=False)
    content: Mapped[str] = mapped_column(Text, nullable=False)
    
    # Vector storage reference (ChromaDB ID)
    vector_id: Mapped[str] = mapped_column(String(255), unique=True, index=True)
    
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    
    # Relationships
    document: Mapped["RegulationDocument"] = relationship(back_populates="chunks")

class ComplianceAnalysis(Base):
    __tablename__ = "compliance_analyses"
    
    id: Mapped[str] = mapped_column(String(36), primary_key=True)
    scrape_job_id: Mapped[str] = mapped_column(
        String(36),
        ForeignKey("scrape_jobs.id", ondelete="CASCADE"),
        nullable=False,
        unique=True,
        index=True
    )
    
    # Analysis results (stored as JSON)
    findings: Mapped[dict] = mapped_column(JSON, nullable=False)
    
    # Metadata
    llm_model: Mapped[str] = mapped_column(String(100))
    total_tokens_used: Mapped[int] = mapped_column(Integer, default=0)
    
    analyzed_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    
    # Relationships
    scrape_job: Mapped["ScrapeJob"] = relationship(back_populates="analysis")

class ApiKey(Base):
    __tablename__ = "api_keys"
    
    id: Mapped[str] = mapped_column(String(36), primary_key=True)
    organization_id: Mapped[str] = mapped_column(
        String(36),
        ForeignKey("organizations.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    
    # Key details
    name: Mapped[str] = mapped_column(String(255), nullable=False)
    key_hash: Mapped[str] = mapped_column(String(128), unique=True, index=True)  # SHA-512
    key_prefix: Mapped[str] = mapped_column(String(12))  # First 8 chars for display
    
    # Status
    is_active: Mapped[bool] = mapped_column(Boolean, default=True)
    last_used: Mapped[Optional[datetime]] = mapped_column(DateTime)
    usage_count: Mapped[int] = mapped_column(Integer, default=0)
    
    # Rate limiting
    rate_limit_per_minute: Mapped[int] = mapped_column(Integer, default=60)
    
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    expires_at: Mapped[Optional[datetime]] = mapped_column(DateTime)
    
    # Relationships
    organization: Mapped["Organization"] = relationship(back_populates="api_keys")

class AuditLog(Base):
    __tablename__ = "audit_logs"
    
    id: Mapped[str] = mapped_column(String(36), primary_key=True)
    user_id: Mapped[Optional[str]] = mapped_column(
        String(36),
        ForeignKey("users.id", ondelete="SET NULL"),
        index=True
    )
    
    # Event details
    action: Mapped[str] = mapped_column(String(100), nullable=False, index=True)
    resource_type: Mapped[str] = mapped_column(String(50))
    resource_id: Mapped[Optional[str]] = mapped_column(String(36))
    
    # Context
    ip_address: Mapped[Optional[str]] = mapped_column(String(45))  # IPv6 support
    user_agent: Mapped[Optional[str]] = mapped_column(Text)
    details: Mapped[Optional[dict]] = mapped_column(JSON)
    
    # Result
    success: Mapped[bool] = mapped_column(Boolean, default=True)
    error_message: Mapped[Optional[str]] = mapped_column(Text)
    
    timestamp: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow,
        index=True
    )
    
    # Relationships
    user: Mapped[Optional["User"]] = relationship(back_populates="audit_logs")

# ============================================================================
# DATABASE DEPENDENCY
# ============================================================================

async def get_db() -> AsyncSession:
    """Dependency for getting database session"""
    async with async_session_maker() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()

# ============================================================================
# DATABASE INITIALIZATION
# ============================================================================

async def init_db():
    """Initialize database tables"""
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    print("✅ Database tables created successfully")

async def drop_db():
    """Drop all database tables (use with caution!)"""
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)
    print("⚠️ All database tables dropped")

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

import hashlib
import secrets

def generate_api_key() -> tuple[str, str, str]:
    """
    Generate a new API key
    Returns: (full_key, key_hash, key_prefix)
    """
    # Generate random key
    full_key = f"rcp_{secrets.token_urlsafe(32)}"
    
    # Hash for storage
    key_hash = hashlib.sha512(full_key.encode()).hexdigest()
    
    # Prefix for display
    key_prefix = full_key[:12]
    
    return full_key, key_hash, key_prefix

def hash_password(password: str) -> str:
    """Hash a password using SHA-512 (use bcrypt in production)"""
    return hashlib.sha512(password.encode()).hexdigest()

def verify_api_key(provided_key: str, stored_hash: str) -> bool:
    """Verify an API key against stored hash"""
    provided_hash = hashlib.sha512(provided_key.encode()).hexdigest()
    return secrets.compare_digest(provided_hash, stored_hash)

# ============================================================================
# EXAMPLE USAGE
# ============================================================================

if __name__ == "__main__":
    import asyncio
    
    async def example_usage():
        # Initialize database
        await init_db()
        
        # Create test organization
        async with async_session_maker() as session:
            org = Organization(
                id="org_test_001",
                name="Test Financial Corp",
                subscription_status=SubscriptionStatus.ACTIVE,
                subscription_tier="enterprise"
            )
            session.add(org)
            await session.commit()
            print(f"✅ Created organization: {org.name}")
    
    asyncio.run(example_usage())
